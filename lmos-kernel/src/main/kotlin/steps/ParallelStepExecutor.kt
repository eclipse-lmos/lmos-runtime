/*
 * SPDX-FileCopyrightText: 2025 Deutsche Telekom AG and others
 *
 * SPDX-License-Identifier: Apache-2.0
 */

package org.eclipse.lmos.kernel.steps

import org.eclipse.lmos.kernel.aggregators.Aggregator
import org.eclipse.lmos.kernel.aggregators.DefaultAggregator
import org.eclipse.lmos.kernel.observe.NoOpStepObserver
import org.eclipse.lmos.kernel.observe.NoOpStepObserverFactory
import org.eclipse.lmos.kernel.observe.ObservationInput
import org.eclipse.lmos.kernel.observe.StepObserver
import org.eclipse.lmos.kernel.observe.StepObserverFactory
import io.micrometer.core.instrument.MeterRegistry
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.TimeoutCancellationException
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.slf4j.MDCContext
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeout
import org.slf4j.MDC
import kotlin.collections.plus

/**
 * Marker interface representing an execution block in the [ParallelStepExecutor].
 * Can be either a [SequenceBlock] or a [ParallelBlock].
 */
sealed interface ExecutionBlock

/**
 * SequenceBlock implements [ExecutionBlock] and highlights all the steps in a sequence:
 *
 * ```
 * .seq()
 *      .step<>()
 *      .step<>()
 *      .end()
 * ```
 *
 * @property steps List of steps to be executed sequentially.
 */
data class SequenceBlock(val steps: List<Step>) : ExecutionBlock

/**
 * ParallelBlock implements [ExecutionBlock] and represents the sequences, their steps and the aggregator:
 *
 * ```
 * .parallel()
 *          .seq()
 *              .step<Step_1>()
 *              .step<Step_2>()
 *              .end()
 *          .seq()
 *              .step<Step_1>()
 *              .step<Step_3>()
 *              .end()
 *          .aggregate<DefaultAggregator>()
 * ```
 * @property sequences List of parallel sequences to be executed concurrently.
 * @property aggregator Aggregator to combine outputs from parallel sequences.
 * @property timeout Time in milliseconds after which parallel execution is cancelled.
 */
data class ParallelBlock(
    val sequences: List<ParallelSequence>,
    val aggregator: Aggregator,
    val timeout: Long
) : ExecutionBlock

/**
 * Allows for parallel execution of sequences and their steps from [StepExecutor].
 *
 * The underlying structure and usage will be as follows, for e.g.:
 *```
 * stepExecutor
 *      .parallel()
 *          .seq()
 *              .step<Step_1>()
 *              .step<Step_2>()
 *              .end()
 *          .seq()
 *              .step<Step_1>()
 *              .step<Step_3>()
 *              .end()
 *          .aggregate<DefaultAggregator>()
 *       .execute(input)
 *```
 *
 * All sequences of steps defined under parallel() are started on a separate Coroutines simultaneously.
 * The steps in each sequence are executed sequentially, one after the other, but the sequences are executed in parallel.
 *
 * As in case of [StepExecutor], each sequence yields an [Output] object.
 *
 * Since multiple sequences can be executed in parallel, there needs to be a mechanism to combine the [Output]s
 * generated by those sequences. This is where [Aggregator] comes in.
 * In most cases, custom implementations of Aggregator will need to be defined. There is however, for basic testing,
 * a [DefaultAggregator] which can be used.
 *
 * @property stepFactory Factory to create step instances.
 * @property meterRegistry Optional Micrometer registry for metrics.
 * @property stepObserverFactory Optional factory for observing step execution.
 * @property steps Optional list of initial sequential steps before [parallel].
 * @property timeout Time in milliseconds after which execution of steps in parallel blocks will be timed out.
 *                   Default is 2 minutes.
 */
class ParallelStepExecutor(
    val stepFactory: StepFactory,
    val meterRegistry: MeterRegistry? = null,
    val stepObserverFactory: StepObserverFactory? = NoOpStepObserverFactory(),
    val steps: List<Step>? = emptyList(),
    val timeout: Long?
) : AbstractStep() {

    private val executionBlocks = mutableListOf<ExecutionBlock>()
    private var stepObserver: StepObserver = NoOpStepObserver()

    /**
     * Creates a SequenceBlock and adds all steps before parallel() to it.
     * This is done to ensure that if there are any sequences supposed to execute before parallel(),
     * they are first added to list of executions and when the execution starts, they are run first.
     */
    init {
        if(!steps.isNullOrEmpty()) {
            executionBlocks.add(SequenceBlock(steps))
        }
    }

    /**
     * Begins a sequential step builder.
     */
    fun seq(): SeqStepBuilder = SeqStepBuilder(this)

    /**
     * Begins a parallel block builder.
     */
    fun parallel(): ParallelBuilder = ParallelBuilder(this)

    internal fun addSequenceBlock(sequenceBlock: SequenceBlock){
        executionBlocks.add(sequenceBlock)
    }

    internal fun addParallelBlock(parallelBlock: ParallelBlock) {
        executionBlocks.add(parallelBlock)
    }

    /**
     * Executes all added execution blocks in order.
     */
    override suspend fun executeInternal(input: Input): Output {

        var currentInput = input
        var currentOutput = Output(Status.CONTINUE, currentInput)

        for (executionBlock in executionBlocks) {

            currentOutput = when (executionBlock) {
                is SequenceBlock -> executeSequenceBlock(currentInput, executionBlock)
                is ParallelBlock -> executeParallelBlock(currentInput, executionBlock)
            }

            if(currentOutput.status == Status.BREAK) return currentOutput
            currentInput = currentOutput.toInput()
        }

        return currentOutput
    }

    /**
     * Executes steps of a sequence.
     *
     * For details, check [SequenceBlock].
     *
     * @param input [Input] object.
     * @param sequenceBlock Contains steps of a sequence.
     *
     * @return [Output] post execution of steps in the [sequenceBlock].
     */
    private suspend fun executeSequenceBlock(input: Input, sequenceBlock: SequenceBlock): Output = stepObserver.observeSteps(ObservationInput(input)) {
        executeSteps(input, sequenceBlock.steps)
    }

    /**
     * Executes steps defined in sequences inside parallel() block.
     *
     * Steps in the same sequence are run sequentially, one after the other, but are run in parallel to steps of
     * other sequences on separate coroutines. For details check [ParallelBlock].
     *
     * Important: The order of the list of [Output]s returned by this function
     * is the same as the order of list of sequences in [parallelBlock].
     *
     * Outputs from each sequence are then combined using [Aggregator].
     *
     * @param input [Input] object.
     * @param parallelBlock Contains sequences, steps and aggregator.
     *
     * @return [Output] containing combined output after execution of parallel sequences.
     */
    private suspend fun executeParallelBlock(input: Input, parallelBlock: ParallelBlock): Output {

        // Execute sequences of steps in parallel.
        val outputs = runParallelSequences(input, parallelBlock.sequences, parallelBlock.timeout)

        // Execute aggregator
        return parallelBlock.aggregator.aggregate(outputs)
    }

    /**
     * Executes steps defined in sequences inside parallel() block.
     *
     * Steps in the same sequence are run sequentially, one after the other, but are run in parallel to steps of
     * other sequences on separate coroutines. For details check [ParallelBlock].
     *
     * Important: The order of the list of [Output]s returned by this function
     * is the same as the order of list of [parallelSequences].
     *
     * If some parallel sequences are timed out, then they are cancelled
     * and their respective Output is initialised with status = BREAK and [TimeoutCancellationException].
     *
     * @param input [Input] object.
     * @param parallelSequences Sequences and their steps to be executed in parallel.
     * @param timeout Time in milliseconds after which parallel execution is cancelled.
     *
     * @return List of [Output]s containing combined output after execution of parallel sequences.
     */
    private suspend fun runParallelSequences(
        input: Input,
        parallelSequences: List<ParallelSequence>,
        timeout: Long
    ): List<Output> = coroutineScope {

        val parallelSeqJobs = parallelSequences.map { seq ->
            async(MDCContext()) {
                stepObserver.observeSteps(ObservationInput(input)) {
                    executeSteps(input.deepCopy(), seq.steps)
                }
            }
        }

        try {
            withTimeout(timeout) {
                parallelSeqJobs.awaitAll()
            }
        } catch (ex: TimeoutCancellationException) {

            parallelSeqJobs.forEach { it.cancel() }

            parallelSeqJobs.map{ parallelSeqJob ->
                if(parallelSeqJob.isCompleted && !parallelSeqJob.isCancelled) {
                    runCatching { parallelSeqJob.getCompleted() }.getOrDefault(Output(Status.BREAK, input))
                }
                else {
                    Output(Status.BREAK, input, errorCause = ex)
                }
            }
        }
    }

    /**
     * Executes the steps defined in input list of [steps] sequentially, one after the other.
     *
     * Same implementation as the one in [StepExecutor].
     *
     * @param input [Input] object.
     * @param steps List of [Step] to be executed.
     *
     * @return [Output].
     */
    private suspend fun executeSteps(input: Input, steps: List<Step>): Output {

        val eligibleSteps = steps.dropWhile { !it.canHandle(input) }
        if(eligibleSteps.isEmpty()) return Output(Status.CONTINUE, input)
        val currentStep = eligibleSteps.first()

        val output = try {
            logStepName(currentStep) {
                stepObserver.observe(ObservationInput(input, eligibleSteps.first()::class.java)) {
                    Measure(currentStep, meterRegistry).execute(input)
                }
            }
        } catch (e: Exception) {
            Output(Status.BREAK, input, e)
        }

        val nextSteps = when (output.status) {
            Status.BREAK -> eligibleSteps.drop(1).filterIsInstance<AbstractProcessingStep>()
            else -> eligibleSteps.drop(1)
        }

        if (nextSteps.isEmpty()) return output
        return executeSteps(output.toInput(), nextSteps)
    }

    private suspend fun <T> logStepName(step: Step, block: suspend CoroutineScope.() -> T): T {
        val stepName = step::class.simpleName.toString()
        val currentContext = (MDC.getCopyOfContextMap() ?: emptyMap()) + ("step" to stepName)
        return withContext(MDCContext(currentContext), block)
    }
}

/**
 * Builder for sequential steps inside [ParallelStepExecutor].
 *
 * @property executor Instance of ParallelStepExecutor.
 */
class SeqStepBuilder(private val executor: ParallelStepExecutor) {

    private val steps = mutableListOf<Step>()

    fun step(step: Step): SeqStepBuilder {
        steps.add(step)
        return this
    }

    fun step(step: Class<out Step>): SeqStepBuilder {
        steps.add(executor.stepFactory.getStep(step))
        return this
    }

    inline fun <reified T : Step> step(): SeqStepBuilder = step(T::class.java)

    fun end(): ParallelStepExecutor {
        executor.addSequenceBlock(SequenceBlock(steps.toList()))
        return executor
    }
}

/**
 * Builder for defining parallel execution blocks.
 *
 * @property executor Instance of [ParallelStepExecutor].
 */
class ParallelBuilder(private val executor: ParallelStepExecutor) {

    private val sequences = mutableListOf<ParallelSequence>()

    fun seq(): ParallelSeqStepBuilder = ParallelSeqStepBuilder(executor.stepFactory, executor.meterRegistry, this)

    fun addSequence(steps: List<Step>) {
        sequences.add(ParallelSequence(steps))
    }

    fun aggregate(aggregator: Aggregator): ParallelStepExecutor {
        executor.addParallelBlock(ParallelBlock(sequences.toList(), aggregator, executor.timeout ?: 120_000L))
        return executor
    }

    fun aggregate(clazz: Class<out Aggregator>): ParallelStepExecutor = aggregate(clazz.getDeclaredConstructor().newInstance())

    inline fun <reified T : Aggregator> aggregate(): ParallelStepExecutor = aggregate(T::class.java)
}

/**
 * Builder for one parallel sequence inside a [ParallelBuilder].
 *
 * @property stepFactory Factory to create step instances.
 * @property meterRegistry Optional Micrometer registry for metrics.
 * @property parallelBuilder Instance of ParallelBuilder.
 */
class ParallelSeqStepBuilder(
    private val stepFactory: StepFactory,
    private val meterRegistry: MeterRegistry?,
    private val parallelBuilder: ParallelBuilder
) {

    private val steps = mutableListOf<Step>()

    fun step(step: Step): ParallelSeqStepBuilder {
        steps.add(step)
        return this
    }

    fun step(step: Class<out Step>): ParallelSeqStepBuilder {
        steps.add(stepFactory.getStep(step))
        return this
    }

    inline fun <reified T : Step> step(): ParallelSeqStepBuilder = step(T::class.java)

    fun end(): ParallelBuilder {

        parallelBuilder.addSequence(steps.toList())
        return parallelBuilder
    }
}

/**
 * Represents a single sequence of steps in parallel execution.
 *
 * @property steps List of steps to execute in this sequence.
 */
class ParallelSequence(
    val steps: List<Step>
)

/**
 * Creates a deep copy of the input, including nested request context and step context.
 */
fun Input.deepCopy(): Input = this.copy(
    requestContext = this.requestContext.deepCopy(),
    stepContext = this.stepContext.toMutableMap() // make a new mutable copy
)

/**
 * Creates a deep copy of the [RequestContext] to avoid shared mutable references.
 */
fun RequestContext.deepCopy(): RequestContext = RequestContext(
    conversationId = this.conversationId,
    turnId = this.turnId,
    tenantId = this.tenantId,
    requestStatus = this.requestStatus,
    additionalInfo = this.additionalInfo.toMutableMap() // avoid shared reference
)
